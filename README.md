# offer
剑指offer相关算法


## 问题6 重建二叉树（ [在线编程链接-牛客网](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6) ）
### 题目描述:
        输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
        假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
        例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回
 
### 解题思路:
    树的基本解题思路都是使用递归的方式解题
    前序遍历序列为 根   左子树 右子树
    中序遍历序列为 左子树 根   右子树
    > 1.前序遍历序列第一个元素为根节点，
    > 2.中序遍历序列中找到该节点值所在的位置，该节点前部分为根的左子树，后部分为根的右子树
    > 3.根据中序遍历序列中左子树的个数和右子树的个数确定前序遍历数列中左子树和右子树的序列部分
    > 4.分别递归左子树的前序遍历序列和中序遍历序列  右子树的前序遍历序列和中序遍历序列
    > 5.直到前序遍历序列和中序遍历序列为空结束遍历

## 问题7 用两个栈实现队列( [在线编程链接-牛客网](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6) )

### 题目描述
    用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
    
### 解题思路：
    队列的基本思想是“先进先出”，栈的基本思想是“先进后出”
    如果使用2个栈的话，可以实现“先进先出”
    一个栈用于push 元素，另一个栈用于pop元素
    如果pop的栈为空时，则从push的栈中将所有的元素都取出放到pop栈
    
## 问题8 旋转数组的最小数字（ [在线编程链接-牛客网](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba) ）
### 题目描述
    把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 
    输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 
    例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 
    NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
### 解题思路
    通常情况下，旋转数组分为左右2部分，左部分的数字不小于右部分的数字
    使用start 和end 两个变量分别寻找左部分的最大值和右部分的最小值，
    这时start 和end 指向数组的值应该是相邻的两个元素，即end - start == 1 且最小值应该是end所指向的数组元素
    使用二分查找的思路：
        （1）start end 分别指向数组第一个元素和最后一个元素
        （2）middle 指向数组中间的位置（middle = start + (end - start)/2,避免整数相加出现溢出）
        （3）如果middle的指向的元素，位于前部分，则start = middle，如果middle指向元素位于后部分，则end=middle
        （4）直到end -start ==1 结束，end 指向的位置即使所需要查找的最小值 
    
    特殊场景:   
                (1)没有进行旋转的数组
                (2)例如：1 0 1 1 1 1   或者 1 1 1 1 0 1 
    针对特殊场景1，需要再使用二分之前判断这种情况，middle指向元素第一个元素，不执行二分查找循环
    针对特殊场景2，只能使用顺序查找
    针对特殊场景1和特殊场景2，二分查找的结束条件为 start 指向的元素小于end 指向元素
    再开始调整start 和end的值时，
        先判断是否满足特殊场景2的情形 即：start end middle指向元素完全相等，若满足，则顺序查找，否则执行二分查找
    
## 问题9 斐波那契数列（ [在线编程链接-牛客网](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3) ）
### 题目描述
    大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
### 解题思路
    非常容易想到的一种解题思路就是：
    （1）通过递归的方式进行计算
        给定需要计算的第n个斐波那契数列，计算前一个和前2个的值，一致计算，直到第1个位置（假设以0开始）
    递归的方式计算起来比较耗费时间，处特殊情况一般不使用递归进行计算，通常都是使用空间换时间的方式，减少计算量
    （2）使用数组存储之前计算的数值，由于n的最大值只有40，空间消耗也不是很大
        首先定义一个n+1的数组，第0个值和第1个值分别是0和1，开始循环，第i个元素的值等于第i-1个元素值加上第i-2个元素的值
    使用上述方法，降低了执行时间，那有又有可能把占用空前进一步降低呢？
    再方法（2）中，再计算第n个斐波那契数列值时，除了前2个元素之外的元素只是计算的时候，后期就不再使用，是不是可以只用2个元素来存储？
    （3）进一步降低空间存储，使用2个元素（first,second）分别存储前n-1个和n-2个元素的值
        从第2个元素开始循环，直到第n+1个元素，
        计算第i个斐波那契数列时，使用临时变量（result）存储第i-1个元素和第i-2个元素，将second的值赋值给first,将result的值赋值给second
        循环结束时，result的值，即为所求的值
### 实验结果比较
    n = 40时
    | 方法  | 执行时间 |
    | 方法1 | 1s321ms  |
    | 方法2 | 2ms      |
    | 方法2 | 0ms      |
    
    n=100时

    | 方法  | 执行时间 |
    | 方法1 | 9s14ms   |
    | 方法2 | 2ms      |
    | 方法2 | 0ms      |
## 问题9 跳台阶( [在线编程-牛客网](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4) )
### 问题描述
    一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
### 解题思路
    首先，当目标台阶为0时，则总共有0种跳法
    然后，当目标台阶为1时，共有1种跳法
    当目标台阶数为2时，共有（1，1）和（2）两种方法
    当目标台阶为3时，共有(1,1,1) (1,2),(2,1)三种方法，
    这三种方法可以转化为 台阶数为2时，继续向上跳一个台阶，和台阶为1时，向上跳2个台阶（共有2种方法）
    当目标台阶为4时，可转化为台阶为3时，继续向上挑一个台阶（共有3种方法），台阶为2时，向上跳2个台阶(2),即5种方法
    当目标台阶为n时，可转换为台阶为（n-1）向上跳一个台阶，台阶为（n-2）时向上跳2个台阶
    即青蛙跳台阶时斐波那契数列的一种情况，直接使用斐波那契数列即可求解
    
## 问题9 变态跳台阶（[在线编程-牛客网](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387)）
### 问题描述
    一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。
    求该青蛙跳上一个n级的台阶总共有多少种跳法。
### 解题思路
    递归思路：
    当n=1时，共有1种跳台阶方法，即f(1)=1
    当n=2时，共有2种跳台阶方法（1）1 1 （2） 2
        f(2)=f(1) + f(0) 此时f(0)为1
    当n=3时，共有4种跳台阶方法（1）1 1 1 （2） 1 2 （3）2 1 （4） 3
        f(3)=f(2) + f(1) + f(0) 此时f(0)为1
    ……
    当n=n-1时，共有f(n-1)=f(n-2) + f(n-3) + f(n-4) +……+f(0),此时f(0)应为1
    当n=n时，共有f(n)=f(n-1) + f(n-2) + f(n-3) +……+f(0),此时f(0)为1
    
    此时 可以发现，f(n) = f(n-1) + f(n-1) = 2 * f(n-1)
    
    非递归思路：
    采用斐波那契数列的计算方法种的数组，设定一个长度为n的数组，每次存储以前计算的结果，如下：

    | target  |  0  |  1  |  2  |  3  |  5  |  6  |  ...  |    n    | 
    |-------- | --- | --- | --- | --- | --- | --- | ----- | ------- |
    | result  |  0  |  1  |  2  |  4  |  8  | 16  |  ...  | 2^(n-1) |
    
    可以从上述结果得出，跳台阶的数目2^(n-1)
### 参考文献
[变态跳台阶](https://blog.csdn.net/qq_14997637/article/details/80638069)    

## 问题9 矩形覆盖[在线编程-牛客网](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6)
### 问题描述
    我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。
    请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
### 解题思路
    通过分析，可以发现该题也可以转换为斐波那契数列的问题
    当n=1时，共有1种方式 f(1): -
    当n=2时，共有2种方式 f(2): (1)- - (2)| |
    当n=3时，共有3种方式 f(3): (1)- - - (2) | |-  (3) - | |
        即 f(3)为f(1)的情况下 加上f(2)的情况
        
    以此类推，f(n) = f(n-1) + f(n-2)
    
## 问题10 二进制中1的个数([在线编程-牛客网](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8))
### 问题描述
    输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
### 解题思路
    比较简单的思路，使用二进制的位运算，统计1的个数，每次都是 n 与 （n-1）与运算
    并将结果赋值给n，统计计算的次数，次数即为1的个数
## 问题11 数值的整数次放
### 问题描述
    给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
### 解题思路
    问题相对简单，需要把所有的情况尽可能的考虑周全，
    （1）如果base为0，则直接返回0
    （2）如果exponent为0，任意数的0次方为1，则返回1
    （3）如果exponent小于0，则需要求倒数
    （4）double类型的数字可能回存在误差，在判断是否相等时，应该使用两数之间的误差小于一定数值时，即为相等
    

    